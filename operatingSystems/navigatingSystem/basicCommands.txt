> INTRO TO OPERATING SYSTEMS AND BECOMING A 
  POWER USER 
You've already learned the basics of computing and you just finished learning about the bits and bytes of computer networking. Now it's time to navigate the Windows and Linux Operating Systems or OSs. But before we dive in, I'd like to introduce myself. We met way back in the first course. But for those of you who might have forgotten or skipped those lessons, my name is Cindy Quach, and I'm a site reliability engineer at Google. The team I work on is responsible for the management and support of Google's entire internal mobile fleet; Android OS, iOS, and chrome OS. Before focusing on mobile, I was a systems administrator on the Linux team, and before that, I was an operations engineer. But like a lot of the Googlers you've met and will meet, I started my career as an IT support specialist. I've been working in IT for seven years now. The first time I can remember interacting with computers was in middle school, when my teacher brought them into our classrooms so we could create fun video and multimedia projects. It was my brother who brought technology into our house. My parents were immigrants from Vietnam and we didn't have a lot of money growing up, so we had to be creative if we wanted to play with a computer at home. I can remember we were spending hours with my brother as he assembled a computer and I would just ask a million questions. Eventually, I wanted to try and build my own computer. So, I gathered up some old parts and saved money to buy new components. I finally put all the parts together from what I remembered my brother doing. But it didn't work out. It turns out I use some incompatible parts but through a lot of trial and error, troubleshooting, and long search sessions on the internet. I finally got it to work. The feeling I got when I heard my computer boot up for the first time was amazing, and before I knew it, I was hooked on computers. I really enjoyed the intense concentration and problem solving required in IT. But I didn't think a career in tech was even possible but then. Once I got to college, I had to find a job to help pay for tuition. And that job was an IT support specialist on campus. That's when I realized that tech is actually something I could pursue as a career. I've been working with computers for as long as I can remember and much of my IT knowledge was based on my own troubleshooting experiences over the years. I was great at troubleshooting issues with operating systems or so I thought, it wasn't until I became a systems administrator on Google's Linux team that I realized just how little I knew about operating systems. I was surrounded by brilliant teammates who maintain code for a large open source operating system projects. Some even had Wikipedia pages written about them. So it was hard not to feel inadequate at times. Like I was learning to walk again as I dove more into Linux, I just wasn't used to working on the command line and it felt overwhelming to use it to troubleshoot obscure issues that popped up. I had to constantly look up commands and figure out where to find certain files, but I didn't let it get the best of me. I took things day by day, and after a year of being on the team, I realized I had progressed incredibly far. One year later, I was building and packaging my own tools then deploying them for everyone to use. As contributing code directly to open source software. Using the command line, had become second nature. There's so much to learn about operating systems and it's one of the reasons why I'm passionate about teaching this course. Learning Linux doesn't have to be scary. It's not impossible to use Windows commands and it's certainly not difficult to get started. So let's just do that and get started. While this course will have some conceptual learning. Will focus more on the practical aspects of the operating system. Not only when you learn how to use the Windows and Linux OSs, we'll also teach you how to interact with these operating systems through the command line. Remember that the command line inputs text commands instead of relying on a graphical user interface or GUI. If this is your first time using a command line for any OS, you may find this a little intimidating at first. That's totally normal, but you'll be well on your way to become a command line wizard by the end of this course. As always, we'll help guide you every step of the way, and you can always re-watch the lessons if you need to take a refresher. Take your time, you got this. We're not only going to teach you how to use the command line in Windows and Linux. You'll also learn how file systems work, and you'll be able to assign different user permissions and roles, which is a super important task in any support role. You'll be able to understand how to use package managers and consider the trade offs between different package managers for Windows and Linux. We'll also teach you about process management, so you understand the nuances of running programs. That could save you valuable time when troubleshooting in the workplace. We'll also take a deeper dive into the remote connection tools you've already been using to help you access other computers, when you're working at a distance. Finally, we'll teach you about OS deployment or how to install OSs on a lot of machines at once. By the end of this course, you'll become a real OS power user, in both the Windows and Linux operating systems. This is an invaluable skillset for anyone pursuing a career as an IT support specialist. After all, we spend most of our time within an operating system. But remember, you'll need to practice, practice, and practice some more to get a firm grip on operating systems. Just like with any skill, you need to really apply yourself to get good at it. Eventually, navigating the operating system will seem like second nature to you. We strongly recommend that you follow along in this course with a computer using one if not both of these operating systems. Navigating a real operating system while following along this course, is a much more efficient way to learn these concepts. If you don't have access to them that's totally okay. You'll be doing active learning exercises in an application called Qwiklabs, to help simulate what it's like to use the Windows and Linux OS. I'm super excited to teach you about Windows Linux OSs. So let's get started.

> LESSON OVERVIEW AND PRACTICE TIPS
We dipped our toes in the Windows and Linux OS's in the first course of this program. Now, let's jump right in and learn how to perform all the common navigational tasks of both operating systems. For Windows, we're going to learn how to navigate the operating system using the GUI and using the command line interpreter or CLI. For Linux, we're only going to focus on learning the command line. The command line interpreter in Linux is called a shell, and the language that we'll use to interact with the shell is called Bash. It's worth calling out that these two operating systems are very similar to one another. So, even if you don't know how to use the Linux GUI, as long as you know how to navigate the Windows GUI, you'll be able to apply those tools to the Linux GUI. It's possible that you'll only be using the Windows GUl in the workplace. Even so, if you learn how to use the Windows command line, this will set you apart from other IT support specialists. You'll soon discover that using the command line in any operating system can actually help you complete your work faster and more efficiently. We surely encourage you to follow along and actually perform the task we do in this course yourself. If you can, pause a video and do the exercises that we do or type out any of the commands we introduce. It will be much easier for you to understand them in this way. We also recommend that you document all the commands that we show you. Either write them down with an old-fashioned pen and paper notebook, or type them out in a doc or text editor. Just write them on a stone if you have to, we just want you to write them down somewhere. You probably won't remember all the commands immediately when we first introduced you to them, but with a little practice, typing the commands will become second nature to you. You can also use the official Windows CMI and Bash documentation that we've provided for you in the supplemental reading, right after this video for reference, if you need to. In this lesson, the content is broken down into two themes. The first is basic operating system navigation, like navigating from one directory to another, getting file information, and removing files and directories. The second theme is file and text manipulation, like searching through your directories to find a specific file, copying and pasting, chaining commands and more. Okay. Enough chit-chat. Let's get started.

> LIST DIRECTORIES IN A G.U.I. 
In operating systems, files and folders or directories are organized in a hierarchical directory tree. You have a main directory that branches off and holds other directories and files. We call the location of these files and directories, paths. Most paths in Windows looks something like this C:\Users\Cindy\Desktop. In Windows, file systems are assigned to drive letters which look like C:, or D:, Or X:. Each drive letter is a file system. Remember that file systems are used to keep track of files on our computer. Each file system has a root directory which is the parent for all other directories in that file system. The root directory of C: would be written C:\, and the root directory of X: would be written X:\. Subdirectories are separated by backslashes, unlike Linux, which uses forward slashes. A path starts at the root directory of a drive and continues to the end of the path. Let's open up this PC and navigate to our main directory. The main directory in a Windows system is the drive that the file system is stored on. In this case, our file system is stored on Local Disk C. From here, I'm going to go to Users, then my User folder cindy, and finally to Desktop. If you look at the top here, you can see the path I'm in. Local disk, Users, cindy, Desktop. That wasn't too hard, right? You can see here in our desktop directory that we have a few folders and files. We have a Puppy's Pictures folder, a Hawaii folder, and a file called My Super Cool File. There are also some files on here that you can't see. We call these hidden files. They're hidden for a few reasons. One is that we don't want anyone to see or accidentally modify these files. They could be critical system files or configs or even worse, embarrassing pictures of you in grade school rocking a mullet. It's okay, you aren't the first person who like their hair to be business in the front and party in the back. Just for fun, let's see what kind of hidden files we have in here. We'll go to the top and click View, then check the hidden items checkbox. Now we can see all the hidden files on our system. Oh, interesting. There is a file named secret_file. As much as I'd like to take a peek at it, whoever created it probably doesn't want us to see what's inside so we're going to leave it alone. Let's go ahead and revert this option so we don't accidentally change something else.
Play video starting at :3:5 and follow transcript3:05
Okay, so what if we wanted to view information about a file? Well, to do this, we can actually just right click and choose Properties. Let's try this for My Super Cool File. This pop up dialog has a lot of information displayed here. Let's break it down. In the general tab, we can see the file name, the type of file, what applications we use to open it, and the location path of the file which is C\Users\cindy\Desktop, then we have the size of the file, and the size on disk. This can be a little confusing. The size of the file is actually the amount of data that it takes up, but size on disk is a little different. It's not something you need to know right now but if you want to learn more about it, you can check out the next supplemental reading. All right, let's move on. Next you have timestamps of when the file was created, last modified, and last accessed. After that our file attributes we can enable for our file. We have Read-Only and Hidden. You might guess that if you check hidden, our file will be hidden and only visible if we enable show hidden items. There are some advanced options too but we won't touch those for now. You'll also notice a few other tabs here at the top. Security, Details, and Previous Versions. We'll talk more about the security tab in a later lesson. The Details tab, basically, tells us the information we just discussed about a file. The Previous Versions tab lets us restore an earlier version of a file so if you made a change to a file and wanted to revert to that change, you could go back to that version. To sum up listing the directories in the Windows GUI, we can see the list of files and folders by default here. You can even change how you want to view them using icons or even a list. Then if you want to get more information about a file, you can look at its properties. Next up, let's see how to view all this information through the Windows CLI.

> WINDOWS: LIST DIRECTORIES IN C.L.I.
It's important to know that there are a couple of command line interfaces or CLIs available in Windows. The first one is called the Command Prompt, command.exe. The second one is PowerShell or powershell.exe. The command prompt has been around for a very long time. It's very similar to the Command Prompt that was used in MS DOS. Since PowerShell supports most of the same commands as Command Prompt and many, many more, we're going to use PowerShell for the exercises in this module. I want to call out that many PowerShell commands that we use are actually aliases for common commands in other shells. An alias is sort of like a nickname for a command. The first command that we'll use is for listing files and directories. Let's start by listing the directories in the root of our C: drive. The C: drive is where the Windows operating system is installed. For many of you, it might be the only hard drive that you have in your computer. To get to the PowerShell CLI, just search in your application's list PowerShell. From here, we can go ahead and launch the PowerShell program. We're going to use the ls or list directory command and give it the path of where we want to look. The path is not actually part of the command but it is a command parameter. You can think of parameters as a value that's associated with a command. Now you can see all the directories in the root of your C: drive. You might just see a few or a whole bunch of directories. It all depends on what your computer is used for. The C: drive root folder is what we call a parent directory and the contents inside are considered child directories. As you continue to work with operating systems, you'll encounter terms that may seem a bit out of place at first but they actually make a lot of sense. Parents and children are common terms that stand for hierarchical relationships in OS's. If I have a folder named dogs and a second folder nested within that folder called Corgi, dogs would be the parent directory and Corgi would be the child directory. Let's look at a few of the common child directories in this folder. Program Files x86. These directories contain most of the applications and other programs that are installed in Windows users. This contains the user profile directories or home directories. Each user who logs into this Windows machine will get their own directory here. Windows, this is where the Windows operating system is installed. If we open a PowerShell and run Get-Help ls, we'll see the text describing the parameters of the ls command. This will give us a brief summary of the commands parameters. But if you want to see more detailed help, try Get-Help ls -Full. Now you can see a description of each of the parameters and some examples of how to use the command. What if we wanted to see all the hidden files in this directory? Well, we can use another useful parameter for the ls command, -Force.
Play video starting at :3:42 and follow transcript3:42
The -Force parameter will show hidden and system files that aren't normally listed with just ls. Now you can see some important files and directories like Recycle Bin. This is where the Recycle Bin lives. When you move files to the Recycle Bin, they're move to this directory instead of being deleted immediately. Program data, this directory contains lots of different things. In general, it's used to hold data for programs that are installed in Program Files. All right, now that you've seen how to take a look around the file system in Windows, lets see what this process looks like in Linux.

> LINUX: LIST DIRECTORIES 
In Linux, the main directory that all other stem from is called the root directory. The path to the root directory is denoted by a slash or forward slash. An example of a path in Linux that starts from the root directory is /home/cindy/Desktop. Just like c:\users\cindy\desktop in Windows. Let's go ahead and see what's under the root directory. We're going to be using the ls or list directory contents command. We also want to give this command, the path, the directory that we want to see. If we don't provide a path, it will just default to the current directory we're in.
Play video starting at ::54 and follow transcript0:54
So ls slash. All right, now we can see all the directories that are listed under the root directory. There are a lot of directories here, and they're all used for different purposes. We won't go through them all, but let's talk about a few of the important ones. Slash bin, this directory stores our essential binaries or programs. The ls command that we just used is a program, and it's located here in the slash bin folder. It's very similar to our Windows program files directory. Slash etc, this folder stores some pretty important system configuration files. Slash home, this is the personal directory for users. It holds user documents, pictures, and etc. It's also similar to our Windows users directory. Slash proc, this directory contains information about currently running processes. We'll talk more about processes in an upcoming lesson. Slash user, the user directory doesn't actually contain our user files like our home directory. It's meant for user installed software. Slash var, we store our system logs and basically any file that constantly changes in here. The ls command has a couple of very useful flags that we can use too. Similar to Windows command parameters, a flag is a way to specify additional options for a command. We can usually specify a flag by using a hyphen then the flag option. This varies depending on the program, though. Every command has different flag options. You can actually view what options are available for a command by adding the dash, dash help flag. Let's see this in action.
Play video starting at :2:35 and follow transcript2:35
There's an incoming wall of text, but don't panic. You don't have to memorize these options. This is mainly used for reference. For now, let's just quickly go through the help menu
Play video starting at :2:51 and follow transcript2:51
At the top here it tells you what format to put the command in. And here it gives you a description of what the command does. This huge chunk of text lists the options that we can use. It tells us what command flags are available and what they do. The dash, dash help flag is super useful, and even experienced OS users refer to it every so often. Another method that you can use to get information about commands is the man command from manual. It's used to show us manual pages, in Linux we call them man pages. To use this command, just run man, then the command you want to look up.
Play video starting at :3:25 and follow transcript3:25
So let's look up man ls.
Play video starting at :3:32 and follow transcript3:32
And here we get the same information as dash, dash help, but with a little more detail.
Play video starting at :3:38 and follow transcript3:38
Okay, back to using the ls command.
Play video starting at :3:42 and follow transcript3:42
Right now, it's not quite friendly to read. So let's make our directory list more readable with the dash l flag for long. This shows detailed information about files and folders in the format of a long list.
Play video starting at :4:2 and follow transcript4:02
Now we can see additional information about our directory and the files and folders in them. Similar to the Windows show properties, the ls command will show us the detailed file information. Let's break down this output starting from the left. The first column here are file permissions, side note, we're going to cover file permissions in an upcoming lesson. Okay, next up is the number of links a file has. Again, we'll discuss this is more detail in a later lesson.
Play video starting at :4:28 and follow transcript4:28
Next, we have the file owner, then the group the file belongs to. Groups are another way we can specify access, we'll talk about this in another lesson too. So then we have the file size. The time stamp of last modification, and finally, the file or directory name. The last slide that we'll discuss for the ls command is the dash a or all option. This shows us all the files in the directory including the hidden files.
Play video starting at :4:59 and follow transcript4:59
You'll notice that I appended two different flags together. This is the same thing as ls -l -a /. Both work the exact same way. The order of the flag determines which order it goes in. In our case, it doesn't matter if we do a long list first or show all files first.
Play video starting at :5:17 and follow transcript5:17
Check out how there are some new files are visible when we use these flag. The dash a or all flag, shows all files including hidden ones. You can hide a file or directory by pre-pending a dot to it. Like the file shown here .I_am_hidden.
Play video starting at :5:35 and follow transcript5:35
We've covered a lot in this video, we've learned how to view detailed information about files with the ls command. We also started using computer paths and we learned how to get help with commands using the dash dash help flag and man pages. We even took a sneak peek at our Linux files system. If I went through any of this a little too quickly, just rewatch the video. We'll meet back up in the next one, where we'll start changing directories in the GUI. See you there.

> WINDOWS: CHANGING DIRECTORIES IN THE C.L.I.
When you first open PowerShell, you'll usually be in your home directory. Your prompt shows you which directory you're currently in, but there's also a command that will tell you where you are. PWD or print-working directory tells you which directory you're currently in. If we want to change the directory that we're in, we can use the CD or change directory command. To use this command, we'll also need to specify the path that we want to change to. Remember, this path can be absolute, which means it starts from this drive letter and spells out the entire path. On the flip side, it can be relative, meaning, that we only use part of the path to describe how to get to where we want to go relative to where we're currently are. I'll show you what I mean in a minute. So right now, we're in C:\Users\cindy. Let's say that instead, I want to go to C:\Users\cindy\documents, what do you think the command would look like here? Here it is, cd C:\Users\cindy\documents. And now we've changed to the documents directory. We use an absolute path to get to this directory, but this can be a little cumbersome to type out. We know that that documents directory is under the cindy folder, so can't we just go up one level to get to that folder? We absolutely can. There's a shortcut to get to the level above your current directory, CD dot dot. Let's run the PWD command one more time. Now, we can see that I'm in C:\users\cindy, the parent directory of where I was before. The dot dot is considered a relative path because it'll take you up one level relative to where you are. Let's go back to the documents folder and try this again, except this time, let's go to the desktop folder using the new command we learned. We know that the desktop and document directories are under the home directory, so we could run CD dot dot then CD desktop, but there is actually an easier way to write this, cd..\Desktop. Let's check PWD one more time. PWD now shows that were in the Desktop folder. Sweet. Another cool shortcut for CD that you can use is CD~. The tilde is a shortcut for the path of your home directory. Let's say I want to get to the desktop directory in my home folder. I can do something like this, cd~\Desktop. We've done quite a bit of typing so far, you might actually be wondering, what would happen if we messed up while typing these directory names? How are we supposed to memorize where everything is, and if it's spelled correctly? Fortunately, we don't have to do that. Our shell has a built-in feature called tab completion. Tab completion lets us use the tab key to auto-complete file names and directories. Let's use the tab completion to get to our desktop from our home directory, if I type D and then tab, the first file or directory starting with D will now complete. Now, if this isn't the file or directory that I was looking for, I can continue to press tab, and the path will rotate through all the options that complete the name that I started to type. So I'll see desktop, and then documents, and then downloads. Take note, that the dot in front of the path of.\Desktop just means the current directory. If I erased this and instead type DE then the only directory that matches is desktop. Tab completion is an awesome feature that you'll be using more and more as you continue to work with commands.

> LINUX: CHANGING DIRECTORIES IN BASH 
Let's do the same thing in Bash. From our desktop we're going to navigate to the documents folder. The commands we used earlier in PowerShell are exactly the same here in bash. Print working directory or PWD again shows us the current path we're in. Yep, looks good. We're currently in our desktop directory, which you can see from /home/cindy/Desktop. To navigate around, we use the CD command just like with Windows. We can give it an absolute path like this cd/home/cindy/Documents, or we can give it a relative path like this cd../Documents. In Bash, the tilde is used to reference our home directory. So, cd~/Desktop will take us back to our desktop, and guess what? We still have that useful tab completion feature in Bash. The difference between Bash tab complete and Windows tab complete is that if we have multiple options, it won't rotate through the options, but instead will show us all options at once like this.

> WINDOWS: MAKING DIRECTORIES IN THE C.L.I.
  AND G.U.I.
Now that we've covered listing and changing directories, let's learn how to add new directories. We can do this in the GUI in a super simple way. Just right-click, new, then folder, and bam, we have a new folder. Now, what if we wanted to do this in the CLI? In PowerShell, the command to make a new directory is called mkdir or make directory. Let's make a new directory called my_cool_folder
Play video starting at ::59 and follow transcript0:59
and there it is. That was easy. What if we wanted to use spaces in our folder name instead of underscores? What do you think would happen if I did this instead? Mkdir my cool folder. That's an error. Mkdir is trying to interpret cool and folder as other parameters to the mkdir command. It doesn't understand those words as valid parameters. Turns out that our shell doesn't interpret spaces the way we do. So, we need to tell it explicitly that this folder name is one single thing. We can do this in a variety of ways. We can surround the name with quotes like, mkdir 'my cool folder', or we can escape to space by using the back tick character, mkdir my` cool` folder. Escaping characters is a pretty common concept when dealing with code. It means that the next character after the back tick should be treated literally. In our example, escaping the space tells the shell that the space after the back tick is part of our filename. While the back tick is the escape character in PowerShell, other shells and programming languages may use another character as an escape character. You'll see this in the next video.

LINUX: MAKE DIRECTORIES IN BASH 
In Bash, the command to make a new directory is the same as in Windows. Let's make a new directory called my cool folder with the mkdir or make directory command. And now, we can verify my cool folder is in our desktop. Instead of using back ticks like in windows to escape a character, in Bash, you can use a backslash. Similar to Windows, you can also use quotes to encompass an entire file name. How do you think you would make a directory called my cool folder in Linux with spaces? mkdir my\ cool\ folder. There it is. Or, mkdir ' my cool folder'. Works as well. If you guessed this, you're right. If you guessed wrong, that's okay. Just re-watch this video so you can get a better grasp of how we came to this conclusion.

> WINDOWS: COMMAND HISTORY 
Picking right up from the last video, let's say we want to make a couple of directories, my_cool_folder2 and my_cool_folder3. We could just type mkdir my_cool_folder2, and then type again mkdir my_cool_folder3, but instead we're going to use another cool PowerShell feature called history. Each and every time you enter in a command, it gets saved into memory and added to a special file. You can go through the previous commands you used with the history command.
Play video starting at ::44 and follow transcript0:44
I'm now showing a list of commands that I entered earlier. This information alone isn't very useful. Instead, there's a better use of the history that lets us quickly scroll through these commands and use them again.
Play video starting at ::57 and follow transcript0:57
We can scroll through these commands with the up or down keys on our keyboard.
Play video starting at :1:1 and follow transcript1:01
I'm going to go up to my previous command, and I should see that I have mkdir my_cool_folder.
Play video starting at :1:13 and follow transcript1:13
Instead of typing the whole thing to make a new folder, I'm just going to append the number 2 to my command.
Play video starting at :1:21 and follow transcript1:21
And boom, a new file is created without having to type everything over again.
Play video starting at :1:26 and follow transcript1:26
Cool, right? You can even search through your previously used commands using the history shortcut Ctrl+R.
Play video starting at :1:35 and follow transcript1:35
From here you can start typing bits and pieces of the command you want to look for, and it'll show you matches. Let's search for the word folder.
Play video starting at :1:45 and follow transcript1:45
I should see the mkdir commands I was using before. Pretty neat. If you're using an older version of PowerShell, it may not have the Ctrl+R feature. If that's the case you can type the # symbol followed by some part of your old command, and then use Tab completion to cycle through the items in your history.
Play video starting at :2:7 and follow transcript2:07
The history feature, along with Tab completion and get-help, will be your best friends while you work in PowerShell. Keep them close to you and get to know them super well. Hmm, our shell is looking a little cluttered. It's kind of hard to see where I'm at, so let's clean up our shell a little bit. We can do that with the clear command. This doesn't wipe your history, it just clears the output on your screen.
Play video starting at :2:31 and follow transcript2:31
It looks a little better.

> WINDOWS: COPYING FILES AND DIRECTORIES 
We've already created a few files and directories, but we need a couple more. We don't want to create them off from scratch. So let's make copies instead. In the Windows GUI, all you need to do is right-click, copy, then paste.
Play video starting at ::32 and follow transcript0:32
You can also use hotkeys if you want. A hotkey is a keyboard shortcut that does some sort of task. In Windows, the hotkey for copy is Ctrl-C, and for paste, it's Ctrl-V.
Play video starting at ::47 and follow transcript0:47
In PowerShell, the command used to copy something CP. We also need to add a file that we want to copy and the path of where we want to copy it too.
Play video starting at :1:1 and follow transcript1:01
Let's copy mycoolfile.text to the desktop.
Play video starting at :1:17 and follow transcript1:17
There you can see mycoolfile.text was added to our desktop. I have a few of these files I want to move over, but I'm feeling a little lazy and don't want to run this command over and over again. So, I'm going to use something called a wildcard to help me copy over multiple files at once. A wildcard is a character that's used to help select files based on a certain pattern. Let's say you want to get all the files that were JPG and copy them somewhere. Then I go on to my documents directory. I have files called hotdog.jpg, cotton-candy. jpg, and pretzel.jpg. I need to come up with a pattern to help me select all these files. What do they have in common besides being named after delicious food? The.jpg extension. Literally, anything else can be in front of the.jpg file extension, and it won't matter. That's what the wildcard asterisk does. It's a pattern for anything. So I'm essentially saying, select all the files with the pattern anything.jpg. So, to copy over all the JPGs in the folder, I can use CP, asterisk symbol,.jpg, and the path I want to copy them to. Let's just verify. There it is. Now, instead of copying files one by one, we can use a single command to get all the files we want. For now, the only select you'll be using is the asterisk for all. Next up, let's say I want to copy over a directory. I'm going to try to copy a folder called Bird Pictures to my desktop. Let's just go back into documents. That's Bird Pictures. Now copy Bird Pictures to desktop. Now, this does exactly what we told you to do. It copies the directory. However, this directory is empty. What it doesn't do, is copy over the contents of the directory. To copy of the contents of a directory, you need to use another command parameter, Recurse. The -Recurse parameter list the contents of the directory. Then if there are any sub-directories in that listing, it'll recurse or repeat the directory listing process for each of those sub-directories. We need to use the -Recurse parameter with copy to copy the contents of the directory along with the directory itself. We're going to use a new parameter Verbose. Copy doesn't output anything to the CLI by default unless there are errors. When we use copy -Verbose, it will output one line for each file the directory being copied. Let's give it a try. Copy Bird Pictures, and the Recurse, and Verbose file. This just messages us that we've already copied Bird Pictures, but what we didn't do, was copy over the file, which is now here. Excellent. Now the directory and all the contents are copied to my desktop.

> LINUX: COPYING FILES AND DIRECTORIES 
In Bash, the exact same Windows command can be used for copying files.
Play video starting at ::19 and follow transcript0:19
Let's take a look at this directory. Let's copy my_very_cool_file.txt to my desktop.
Play video starting at ::39 and follow transcript0:39
And there it is. We can also use the same asterisk wildcard to select patterns. Since this is similar to our Windows copy command, what do you think we can use to copy over the .png files in this directory?
Play video starting at ::54 and follow transcript0:54
I have files called Pizza.png, Soda.png, Cake.png. So I can use copy *.png, then the desktop directory. Now if I look at my desktop again, there they are.
Play video starting at :1:14 and follow transcript1:14
The same copy rules apply in bash. If we want to copy over a directory, we have to recursively copy over the directory to get all the contents. The flag for recursive copy is dash r. If I want to copy over my cat pictures folder to the desktop, I can do something like this.

> WINDOWS: MOVING & RENAMING FILES AND 
  DIRECTORIES 
We talked about making and copying files and directories so far. But what if we wanted to rename something that we've created? Well, in the Windows GUI, if you are to rename a file, we just right-click and rename.
Play video starting at ::29 and follow transcript0:29
In the command line, if we wanted to rename a file, we can use the move or move item command. It lets us rename files. Lets move the file without changing the directory that it's stored in. On my desktop here, I have blue document and I'm going to move or rename it to yellow document. Now, you can see that I have a yellow document. As you might guess, the move command also lets us move files from one directory to another. Let's move the yellow document into My Documents.
Play video starting at :1:27 and follow transcript1:27
I can verify that. There it is, cool. You can even move multiple files by using wildcards. And now you can see, the rest of my colored documents went into My Documents.

> LINUX: MOVING & RENAMING FILES AND DIRECTORIES 
The exact same command can be used for Linux. Mv, or move, can rename and move files in directories.
Play video starting at ::19 and follow transcript0:19
Same thing applies here.
Play video starting at ::23 and follow transcript0:23
I'm going to move my red_document and rename it to blue_document.
Play video starting at ::40 and follow transcript0:40
Now we can see it's been renamed to blue_document.
Play video starting at ::43 and follow transcript0:43
Then, I'm going to move the blue_document in to the documents folder.
Play video starting at ::56 and follow transcript0:56
There it is. Using wildcards, we can move multiple files at once, just like Windows.
Play video starting at :1:4 and follow transcript1:04
Let's move all of the underscored document files here to our desktop. Now if we check the desktop, there they are.

> REMOVING FILES AND DIRECTORIES 
All righty, now that we've learned how to list, create, and move around files in directories, let's start removing them. In the Windows GUI, if you wanted to remove a file or folder, just right-click and delete.
Play video starting at ::29 and follow transcript0:29
The file ends up in the recycle bin, which you can find on your desktop.
Play video starting at ::37 and follow transcript0:37
If you wanted to restore a file here, you could just right-click and Restore.
Play video starting at ::43 and follow transcript0:43
If you empty your bin for any reason you won't be able to retrieve those files. In PowerShell, the command to remove files and directories is rm or remove. Take caution when using remove because it doesn't use the recycle bin. Once the files and directories are removed, they're gone for good. Let's remove a file called text1.txt in my home directory.
Play video starting at :1:8 and follow transcript1:08
We can see, There it is. I'm just going to remove it.
Play video starting at :1:19 and follow transcript1:19
And now it's gone. The remove command might seem like a dangerous weapon in the wrong hands. Fortunately, there are safety measures in place that only give this ability to users that are actually authorized to use it.
Play video starting at :1:31 and follow transcript1:31
We'll talk more about file permissions in a different lesson. But let's take a quick look at what I mean.
Play video starting at :1:37 and follow transcript1:37
Let's remove a file called important_system_file.
Play video starting at :1:49 and follow transcript1:49
I get an error message saying that I don't have permission to delete this file.
Play video starting at :1:54 and follow transcript1:54
In some cases like this one, it's because it's been marked as a system file. In other cases, it might be because I don't have enough permissions in the file system to remove the file. I do have the right permissions this time, but since it is an important file, PowerShell wants to make sure that I meant to do this.
Play video starting at :2:10 and follow transcript2:10
If I repeat the command with the -Force parameter, remove will go ahead and remove the file. Let's take a look.
Play video starting at :2:22 and follow transcript2:22
-Force, And you can see the file's gone. If the file belongs to someone else, or if I'm not an administrator, then I might not have the right permissions to remove the file. In that case I'll need to access an administrative account to remove the file. Okay, let's try removing a directory with remove next.
Play video starting at :2:52 and follow transcript2:52
Here we go. Here's another place where PowerShell is going to ask us if we really meant to do this. Since this is in a directory, it contains other files. And we did not use the -Recurse parameter. We see a prompt asking us to confirm if we really want to remove the directory and all its contents. We can say Yes or Yes to All to continue. We can also cancel this command and run it again with the -Recurse parameter. That way, PowerShell knows that we understand the consequences of what we're doing.
Play video starting at :3:20 and follow transcript3:20
So let's go ahead and cancel this and try again.
Play video starting at :3:25 and follow transcript3:25
-Recurse.
Play video starting at :3:33 and follow transcript3:33
Yeah, now it's gone. And that's the remove command in a nutshell. Again, because of the nature of this command, you'll want to be extra careful when removing files or directories.

> LINUX: REMOVING FILES AND DIRECTORIES 
To remove files from Linux, just like in Windows, we can use the rm or remove command.
Play video starting at ::21 and follow transcript0:21
Let's remove this text1 file.
Play video starting at ::32 and follow transcript0:32
And just like that, it's gone. Similar to Windows, we get a message if we try to remove something that we shouldn't be able to.
Play video starting at ::41 and follow transcript0:41
Let's remove this self_destruct_button.
Play video starting at ::46 and follow transcript0:46
Awesome, everything is working as intended.
Play video starting at ::48 and follow transcript0:48
Next let's try removing a directory. If you thought to yourself that we need to also recursively remove this directory, you'd be right, excellent deduction skills.
Play video starting at :1: and follow transcript1:00
So rm -r, let's remove the misc_folder directory.
Play video starting at :1:7 and follow transcript1:07
And if we check the misc folder is now gone. Remember, when using rm command, take extra precaution that you aren't removing something important by accident.
