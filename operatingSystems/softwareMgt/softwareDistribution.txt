> WINDOWS: SOFTWARE PACKAGES 
Have you ever wondered how we get software, like the apps in the App Store, or packages on the Internet to install on our devices? Wonder no more. Developers and organizations that make the software we use, generally package them up nicely for us. In most cases, all we need to do is click install and the package gets installed for us. Packaging comes in all sorts of shapes and sizes. It's just like how you'd package a gift for someone. You could put it in a box or a bag, but the contents are what really matter. Developers have different ways to package software using software compiling tools. But at the end result is a package. In the next few videos we'll discuss some of the most common package types you'll see when you work in IT support. In Windows, software is usually packaged as a dot exe or executable file. Executable files contain instructions for a computer to execute when they're run, like copy this file from here to here, install this program, or more generically, perform this operation. The concept of an executable file isn't unique to Windows, but Windows has its own special implementation of them in the form of the exe's. They're created according to Microsoft's portable executable or PE format. Although we won't get into the details of the PE format, it's good to know that exe files don't just contain instructions for the computer to perform. They also include things like text or computer code, images that the program might use, and potentially something called an msi file. A Microsoft install package or msi is used to guide a program called the Windows Installer in the installation, maintenance, and removal of programs on the Windows operating system. Besides using the GUI setup wizard to guide the user in installing the program, the Windows installer also uses the msi file to create instructions on how to remove the program, if the user wants to uninstall it. Windows executable files are usually used as starting points to bootstrap the Windows installer. In this case, they might just contain an msi file and some instructions to start the Windows installer and read it. Alternatively, executables can be used as stand-alone, custom installers, with no msi file or usage of the Windows installer. If they're packaged this way, the exe file will need to contain all the instructions that operating system needs to install the program. So, when would you use an msi file and the Windows installer? And when would you use an executable with a custom installer packaged in something like setup.exe? Great questions. If you want precise granular control over the actions Windows takes when installing your software, you might go the custom installer route. This can be tricky though, especially when managing things like code dependencies, which we'll talk about later. On the flip side, using the Windows installer guided by an msi file takes care of a lot of the bookkeeping and set up for you, but it has some pretty strict rules about how the software gets installed. As of Windows 8, Microsoft has introduced a platform to distribute programs called the Windows Store. The Windows Store is an application repository or warehouse, where you can download and install universal Windows platform apps. Those are the applications that can run on any compatible Windows devices like desktop PCs, or tablets. These programs use a format called appx to package their contents and act like a unit of distribution. We won't go into detail about appx packages, but it's good to know they're out there giving you another option for packaging software. Feel free to read more about appx packages and how to make them in the supplemental readings I've included after this video. We learned how to install exe packages in an earlier course. To install an exe from the GUI, all we need to do is double click on the executable then go through the installation process provided, either by the executable itself or the Windows installer. That's pretty straightforward, but what about installing software from the command line? And why would you need to do this in the first place? Hold onto your desktops because you're about to find out. Installing executables from the command line can be handy in lots of IT support scenarios, including automatic installations. You might want to write a script or use a configuration management tool to install some software automatically without needing a human to click buttons in an installation wizard. So, how can you install an executable from the command line? The answer, it depends. Pretty unsatisfying, I know. Running exe files from the command line is pretty simple. You open up a Command Prompt or PowerShell, change in to directory where the executable is, and type in its name.
Play video starting at :5:4 and follow transcript5:04
You could also just type the absolute path of the exe from wherever you are in the file system, like this, C:\users\cindy\desktop\hello.exe. Running from an installer from the command line is similar, but will potentially have more options for installation. Depending on the installer, you might have flags for things like a silent installation, where nothing shows up on the screen and the package is installed quietly, or you might get an argument to have the computer reboot automatically after the package is installed. You can check out the options for packages created by using the Microsoft Self-Extractor in the supplemental reading for a better idea of what we are talking about. A given installer might have these kinds of options for installing from the command line, but they vary from vendor to vendor. The options available for a Microsoft package might differ from the options for a Mozilla package. Pro tip, try using the slash question mark parameter when running a package from the command line to see what kinds of sub commands the package might support. If the package doesn't have any help related options, your best bet is to check out the vendor's documentation for what kinds of installations their software packages support.

> LINUX: SOFTWARE PACKAGES 
In Linux, there are lots of different distributions and each might have different package types. For example, in the Linux distribution or Distro, Red Hat, the packages that are used are.rpm or Red Hat Package Manager packages. We won't cover how to work with RPM packages, but just be aware that packet types can change when you're working with different Linux distributions. If you're interested in learning more about RPM packages, I've included a link in the supplementary reading right after this video. In this course, we'll be working with Debian packages which Ubuntu uses. A Debian package is packaged as a.deb file for Debian. You've already learned how to install a Linux package using the help of a package manager in the first course on technical support fundamentals. We'll dive deeper into this in a later video, but let's focus now on how to install a single standalone Debian package. You'll have to work with standalone Debian packages, especially when developers package and release their software on different websites. To install a Debian package, you'll need to use the D package or Debian package command. There is a standalone package here for the open source text editor, atom. Let's go ahead and install it using D package. We have to use the iFlag for the install, and that's it. Now it's installed on this computer. How about if we wanted to remove a package? To do that, we use the R or remove flag.
Play video starting at :1:44 and follow transcript1:44
And that's how you install and remove a standalone Debian package. Pretty simple, right? You can also list the Debian packages that are installed on your machine with a D package dash L. The L is for list. There are lots of programs on here. It looks kind of messy. Can you think of another command that we've used before that would help us search if a certain package is installed? That's right. The grep command. Let's say we want to search for the atom package we just installed. Keep in mind I just uninstalled it, so am just going to install it really quickly. Now let's run D package dash L grep atom. Here, we have the D package dash L command that's been piped to grep. Remember, the pipe command takes the standard output of one command which in this case is the output of the D package dash L. Then, it sends it to the standard input of the command it pipes to. In this case, grep. If we run this command, it shows us that atom is definitely in the list of packages here. Just remember that when using grep, it lists other results that have the search terms in the name. Just like that, we've learned how to install any Debian package in Linux. We're really cooking now. Great work.

> MOBILE APP PACKAGES 
Now, let's talk about software and mobile operating systems. We're going to mostly use examples from iOS and Android. But other mobile operating systems work in a similar way. If your mobile device is using a specialized OS, you'll find information on how that software works and the devices documentation. Software for mobile OS's is distributed as mobile applications or apps. Apps have to come from a source that the mobile device has been configured to trust. On most OS's, you can't just download an app from a random website and install it. Instead, mobile operating systems use app stores. App stores are a central managed marketplace for app developers to publish and sell mobile apps. The App Store app acts like a Package Manager, and the App Store Service acts like a package repository. People use App Stores to access free and paid applications from a central source through a single interface. Apps published through an App Store have usually been through a security review and have been approved by the store owner. Apps published through an App Store are signed by the developer of the app. Though OS is configured to only trust code that's been signed by publishers that it recognizes. We'll talk more about co-signing in a future module. For now, just think of it like signing a letter. The developer is saying I wrote this. There's one way that code signing is different than signing a letter though. If anyone changes the code, the signature becomes invalid. This lets the operating system know if the code's been tampered with. Centralized App Stores work great for apps that are available to the public. But what if your organization needs to run some type of custom App? You'll need to use enterprise app management, which allows an organization to distribute custom mobile apps. These apps were developed by or for the organization, and aren't available to the general public. Enterprise apps are assigned with an enterprise certificate that has to be trusted by the devices that are installing the applications. As an IT Support Specialist, you might help manage enterprise app installation through the mobile device management or MDM service, which we'll learn about in a future video. There's one other way to install an app into a mobile OS, and that's called side-loading. Side-loading is where you install mobile apps directly without using an App Store. Side-loading packages is riskier than installing through an App Store, and you would generally only do this if you're an app developer. Mobile apps are standalone software packages. So they contain all their dependencies. When you install an app, it will already have everything it needs to run baked in. Mobile apps are assigned a specific storage location for their data. As you use a mobile app, anything that's changed or created with that app will end up in that apps assigned storage location or cache. So resetting a mobile app to how it was when it was first installed is a simple as deleting or clearing the cache. In your IT support role, you might help people troubleshoot mobile apps. Clearing the cache will remove all changes to the settings and sign out of any accounts that the app was signed into. It might not be the first thing you should try when trying to wrinkle in unruly app. But it is a great technique for when things are really broken. Check out the supplemental reading for a guide on how to do this. Mobile devices will usually be configured to check for app updates on a regular schedule. In IT support, you might need to make sure an app is updated. You'll find details on how to check for app updates in the supplemental reading.

> WINDOWS: ARCHIVES 
One type of package that we haven't discussed yet isn't really a package at all, it's an archive. An archive is comprised of one or more files that's compressed into a single file. Package archives are basically the core or source software files that are compressed into one file. When we install software from a source archive, it's referred to as, installing from source. Popular archive types you'll see are .tar, .zip, and .rar. To install software found in an archive, you first have to extract the contents of the archive so you can see the files inside. Then, depending on what type of code it was written in, you have to use a specific method to install it.
Play video starting at ::53 and follow transcript0:53
We won't discuss how to install from source, since it changes depending on what language the software was written in. But we'll discuss how to extract the contents of an archive, which you'll have to do a lot as an IT support specialist.
Play video starting at :1:5 and follow transcript1:05
It's not just software that's stored in an archive, anything can be archived, like pictures or music files. You'll see these a lot in IT support.
Play video starting at :1:15 and follow transcript1:15
To make things more complicated, archive types have lots of different way they can be extracted. Luckily, there's a very popular tools in windows for file archiving and unarchiving different file types, like .rar .zip and tar. This is the open source tool 7-zip. It's already installed on my computer.
Play video starting at :1:35 and follow transcript1:35
If you want to download it yourself, I've included a link in the supplemental reading.
Play video starting at :1:41 and follow transcript1:41
There's an archive on my desktop called colors.zip.
Play video starting at :1:45 and follow transcript1:45
Let's go ahead and extract this archive so that we can see the files inside. I'm just going to right click, 7-Zip, extract, here. It looks like there are a bunch of files inside of this archive.
Play video starting at :2:1 and follow transcript2:01
Besides unarchiving files, you can also archive files. I'm going to make a new folder called new colors.
Play video starting at :2:14 and follow transcript2:14
Then, I'm going to add this new blue dot text file and the old colors in this folder.
Play video starting at :2:22 and follow transcript2:22
Then, I'm just going to archive it with 7-Zip and Add to archive. Click OK.
Play video starting at :2:31 and follow transcript2:31
Pretty cool, right? Now, if you wanted to send someone a bunch of files in an email, you don't have to send them one by one. Instead, you can combine them all in one archive and send one single file. If you're using PowerShell version 5.0 of greater, you can actually extract and compress archives right from the command line. Let's say you've got a bunch of files in a folder called cool files on your desktop, that you'd like to add to the new zip file.
Play video starting at :2:59 and follow transcript2:59
After you've opened up the PowerShell command line interface, you can issue this command, Compress-Archive.path.
Play video starting at :3:12 and follow transcript3:12
CoolFiles, and then we're just going to make a new archive in the desktop called CoolArchive.zip. Now, if we check our desktop.
Play video starting at :3:34 and follow transcript3:34
There you should see it, CoolArchive.zip. This will take everything from the desktop CoolFiles directory, and compress it into this CoolArchives.zip

> LINUX: ARCHIVES 
7-Zip is also available to use in Linux. We've already installed the package p7zip-full, which is what the Linux version of 7-Zip is. To extract a file using 7-Zip, use the command 7z and the flag e for extract and then the file you want to extract. For example, let us extract this tar file in my home directory.
Play video starting at ::43 and follow transcript0:43
And just like that, we now have the extracted contents. There are lots of other tools out there for archiving and unarchiving files. One tool that lots of people use, that's already installed on most Linux distros is the tar command. We won't go over how to use this command, but if you'd like to read more about it, check out the next supplemental reading. You'll see lots of different types of archives as you work with Windows and Linux. Just keep in mind that different archive types might require different commands to extract. So, you've learned what the standalone packages are for Windows and Linux along with some of the common archive types. Well done. Next we'll dive a little deeper into packages and some issues you might encounter when you install a standalone package.

> WINDOWS: PACKAGE DEPENDENCIES 
Packages of software usually rely on other pieces of code in order to work. Let's say you're installing a game on your Windows computer. The program might need to do some calculations to make the physics of the game work properly and render the results in the form of graphics on the screen. To perform these tasks, the game might have a dependency on a physics engine to do the calculations and a rendering library to show the sweet graphics on the screen. In order for the game to work, you'll have to have all that software available to the game. Counting on other pieces of software to make an application work is called having dependencies since one bit of code depends on another in order to work. In our example, the game depends on both the physics engine and a rendering library to run. But wait, what do we mean when we refer to a library? You can think of the library as a way to package a bunch of useful code that someone else wrote. This code is bundled together into a single unit. Programs that want to use the functionality that the code provides can tap into it if they need to. In Windows, these shared libraries are called dynamic-link libraries, or DLL for short. You can find out more details about dynamic link libraries in the next reading.
Play video starting at :1:22 and follow transcript1:22
One super useful feature of a DLL is that the same DLL can be used by lots of different programs. This means all that shared code doesn't need to be loaded into memory for each application that wants to use it, so less memory overall is used. Windows applications typically have many dependencies all located together in a single installation package. Along with something called an MSI file that tells the Windows Installer how to put it all together.
Play video starting at :1:51 and follow transcript1:51
This means that a given installation package will have all the resources and dependencies like DLLs, right there in the package. The Windows Installer will also handle managing those dependencies and make sure they are available to the program. In the old days, things weren't always so great. Imagine this scenario. A video player you've been using to play movies on your computer uses a graphics DLL to display films on your screen. A new game just came out that you want to play, so you install that too.
Play video starting at :2:21 and follow transcript2:21
The game comes along with a new version of that graphics library. So the game installer updates the existing version with the new DLL. All of a sudden, your video player stops working. It turns out the video player doesn't know how to use the new version of the DLL, which is a pretty big bummer. On modern Windows Operating Systems though, DLL hell is a problem of the past. To fix it, most shared libraries and resources in Windows are managed by something called side-by-side assemblies or SxS.
Play video starting at :2:53 and follow transcript2:53
Most of these shared libraries are stored in a folder at C:\Windows\WinSxS. If an application needs to use a shared library to perform a task, that library will be specified in something called a Manifest. This tells Windows to load the appropriate library from the SxS folder. The SxS system also supports access to multiple versions of the same shared library automatically. So when you install software, you don't pull the rug out from underneath the programs you've already got. In addition to manifest, the SSX system and installers bundling dependencies together in their installation packages. You can use a Windows Package Manager to help install and maintain the libraries and other dependencies that your installed software needs to use. We'll talk about this in more detail in our lesson on Windows package managers. We'll give you preview using the Windows package management feature for PowerShell. Using a Windows package management cmdlet called Find-Package, you can locate software, along with its dependencies right from the command line.
Play video starting at :4:3 and follow transcript4:03
By the way, a cmdlet is basically the name we give to Windows PowerShell commands that use the verb-noun format. We've already used lots of cmdlets such as get-help, select-string etc. There are hundreds of cmdlets built into Windows and you can even write your own. Okay, back to my task at hand. Let's say you wanted to install the Sysinternals package. Which is a set of tools released by Microsoft that can help you troubleshoot all sorts of problems on your Windows computers.
Play video starting at :4:32 and follow transcript4:32
You could download the Sysinternals package from the Microsoft Website or you could use the package management feature.
Play video starting at :4:39 and follow transcript4:39
First we'll need to open up a PowerShell terminal by typing in PowerShell from the start menu.
Play video starting at :4:50 and follow transcript4:50
Then we can try to locate the sysinternals package by executing this command. Find-Package sysinternals-IncludeDependencies.
Play video starting at :5:8 and follow transcript5:08
An error. No match found. What's that all about?
Play video starting at :5:13 and follow transcript5:13
This exception was generated because the default source of packages in PowerShell is the PowerShell gallery, which doesn't contain the Sysinternals package.
Play video starting at :5:22 and follow transcript5:22
Luckily, all we need to do is tell PowerShell about a place where it can find the Sysinternals package. And that's a package repository called Chocolatey. We'll dip into more about Chocolatey in the package manager video. But for now, just know it's a place where all kinds of windows software packages live. So, before we can install any packages, we need to add a package source that tells our computer where it can find the packages we want to install. Since we want to use Chocolatey to find our packages, we need to add it as a package source. We're going to do that with the PowerShell command Register-PackageSource. Let's go and type Register-PackageSource-Name chocolatey-ProviderName Chocolatey-Location,
Play video starting at :6:19 and follow transcript6:19
.org/api/v2.
Play video starting at :6:24 and follow transcript6:24
We can verify both sources of software are now good to go with the Get-PackageSource command.
Play video starting at :6:35 and follow transcript6:35
And then, try to locate our package and its dependencies again with Find-Package, sysinternals-includeDependencies. Sweet! Now that we know that’s the package we want, we can use a cmdlt called Install-Package to actually install Sysinternals and its corresponding dependencies. We’ll do that in a later lesson. Now it's time for snack break. All this Chocolatey talk made me hungry.

> LINUX: PACKAGE DEPENDENCIES 
Let's see what a package dependency would look like and Linux. We learned how to install a standalone package in Linux using dpkg in the last lesson. Let's install one more package. I downloaded the Google Chrome browser here in my desktop and I want to install it with sudo dpkg -i google - chrome. Wait a minute, what's this error I'm getting? Dependency problems prevent configuration of google chrome stable. This is saying it can't install Google Chrome because it's dependent on another package that isn't currently installed on this machine. So before we can install Chrome, we have to install this package lib app indicator one. While a standalone package installer like dpkg may be quick to use, it doesn't install package dependencies for us. In Linux, these dependencies can be other packages or they could be something like shared libraries. Linux shared libraries similar to Windows dlls are libraries of code that other programs can use. So what do you do if you're stuck with a dependency error? You could install the dependencies one by one. Sure. But in some cases, you might see more than just one dependency. You might even see 10. This is especially true in Linux. It's not that fun to continually install programs just so you can get one program to work. Luckily for us, that's where package managers come in. Package managers come with the works to make package installation and removal easier, including installing package dependencies. We'll talk about package managers in the next lesson but for now, it's enough to know that if you install a standalone package, you won't automatically install its dependencies.

